// Invert the matrix m, but return the determinant separately rather than// dividing through, i.e. return the numerators in the result matrix res,// and the single common denominator, det, separately.//void Invert_rational_terms(const Matrix33t<T>& m,                           Matrix33t<T>* res, T* det){  // 9 floating-point ops  double d01d12md11d02 = m.mat[0][1] * m.mat[1][2] - m.mat[1][1] * m.mat[0][2];  double d01d22md21d02 = m.mat[0][1] * m.mat[2][2] - m.mat[2][1] * m.mat[0][2];  double d11d22md21d12 = m.mat[1][1] * m.mat[2][2] - m.mat[2][1] * m.mat[1][2];  // 5 floating-point ops  *det =    m.mat[0][0] * d11d22md21d12 -    m.mat[1][0] * d01d22md21d02 +    m.mat[2][0] * d01d12md11d02;  // 19 floating-point ops  res->set(d11d22md21d12, -d01d22md21d02, d01d12md11d02,           m.mat[2][0] * m.mat[1][2] - m.mat[1][0] * m.mat[2][2],           m.mat[0][0] * m.mat[2][2] - m.mat[2][0] * m.mat[0][2],           m.mat[1][0] * m.mat[0][2] - m.mat[0][0] * m.mat[1][2],           m.mat[1][0] * m.mat[2][1] - m.mat[2][0] * m.mat[1][1],           m.mat[2][0] * m.mat[0][1] - m.mat[0][0] * m.mat[2][1],           m.mat[0][0] * m.mat[1][1] - m.mat[1][0] * m.mat[0][1]);  // 33 total floating-point ops}template <class T>int Invert(const Matrix33t<T>& m, Matrix33t<T>* res){  T det;  // 33 floating-point ops  Invert_rational_terms(m, res, &det);  if (0.0 == det) return 0;  // 1 floating-point op  T det_inv = 1.0 / det;  // 9 floating-point ops  *res *= det_inv;  // 43 total floating-point ops  return 1;L